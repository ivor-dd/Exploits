import asyncio
import concurrent.futures
import requests

import signal
import time

from collections import Counter

class TimeoutException(Exception):
    pass

def handler(signum, frame):
    raise TimeoutException()

signal.signal(signal.SIGALRM, handler)

def connection_loss(method):
    '''
    Will hard exit if no connection exists after second attempt
    Will repeat if connection is simply slow or interrupted
    '''
    def wrapper(*args):
        while (not args[0].received):
            signal.alarm(10)
            try:
                method(*args)
            except TimeoutException as e:
                input('Timeout: Check connection and press enter to continue')
            else:
                args[0].received = True
        args[0].received = False
    return wrapper

class AsyncRequest:
    def __init__(self, max_workers):
        self.max_workers = max_workers
        self.received = False
        self.results = []
        self.responses = Counter([])

    async def async_get(self, url_array):
        self.results = []
        with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
            loop = asyncio.get_event_loop()
            futures = [
                loop.run_in_executor(
                    executor, 
                    requests.get, 
                    url,
                )
                for url in url_array
            ]
            for response in await asyncio.gather(*futures):
                self.results.append([response.status_code, len(response.content)])

    #@connection_loss
    def request(self, url_array):
        while (not self.received):
            signal.alarm(10)
            try:
               asyncio.run(self.async_get(url_array))
            except TimeoutException as e:
                print('Timeout: Trying again')
            else:
                self.received = True
        self.received = False
        self.responses = Counter(map(tuple, self.results))
        '''
        loop = asyncio.get_event_loop()
        loop.run_until_complete(self.async_get(url_array))
        self.responses = Counter(map(tuple, self.results))
        '''

    def prophecy(self):
        element = list(self.responses.most_common()[-1][0])
        return self.results.index(element)